import asyncio
import os
import json
import logging
import time
from typing import Any, Dict, List

from fastapi import FastAPI, Form, BackgroundTasks
from fastapi.responses import Response
from twilio.rest import Client
from dotenv import load_dotenv

# load .env
load_dotenv()

# -------------------------
# Configuration
# -------------------------
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("whatsapp_webhook")

app = FastAPI()

TWILIO_ACCOUNT_SID = os.getenv("TWILIO_ACCOUNT_SID", "")
TWILIO_AUTH_TOKEN = os.getenv("TWILIO_AUTH_TOKEN", "")
TWILIO_WHATSAPP_FROM = os.getenv("TWILIO_WHATSAPP_FROM", "whatsapp:+14155238886")

twilio_client = Client(TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN)

# -------------------------
# DYNAMIC TEMPLATE CONFIGURATION
# -------------------------
TEMPLATE_SIDS = {
    2: "HX5c0ca19c79aa550301fa311403f6518a",
    3: "HX0cd36a7dfd8397ca2fa2082dde62dc6f",
    4: "HXfee1879cf2a8b515d1f56a27cbf656dd",
    5: "HX7d603ea61c4bf0057f80936439e9576e",
    10: "HX86b4c4d62a26a71dae214931b8855a51"
}

IMAGE_MAX_WIDTH = int(os.getenv("IMAGE_MAX_WIDTH", "1600"))
IMAGE_QUALITY = int(os.getenv("IMAGE_QUALITY", "95"))

# -------------------------
# Helper Functions
# -------------------------
def build_cdn_url(prod_id: str) -> str:
    if not prod_id: return ""
    return f"{prod_id}s.jpg?im=Resize,width={IMAGE_MAX_WIDTH},quality={IMAGE_QUALITY}"

def normalize_search_results(raw: Any) -> List[dict]:
    out: List[dict] = []
    if not raw: return out

    if isinstance(raw, dict):
        for k, v in raw.items():
            if isinstance(v, dict):
                meta = dict(v)
                if not any(x in meta for x in ("productId", "product_id", "id", "key", "prod_id")):
                    meta["product_id"] = k
                out.append(meta)
        return out

    if isinstance(raw, list):
        for item in raw:
            if isinstance(item, dict):
                out.append(item)
            elif isinstance(item, (list, tuple)) and item:
                first = item[0]
                if isinstance(first, dict):
                    out.append(first)
    return out

def load_json_response():
    """Reads the local output.json file safely."""
    try:
        with open("api_out.json", "r") as f:
            return json.load(f)
    except FileNotFoundError:
        logger.error("❌ output.json file not found!")
        return {}
    except json.JSONDecodeError:
        logger.error("❌ output.json contains invalid JSON!")
        return {}

# -------------------------
# Background Logic
# -------------------------
def process_webhook_logic(Body: str, From: str, start_time: float):
    user_number = From
    logger.info(f"Processing logic for {user_number}")

    # --- Step 1: LOAD JSON FROM FILE ---
    resp = load_json_response()
    
    assistant_message = resp.get("assistant_message", "Here are your products")
    raw_results = resp.get("search_results", [])
    products_found = normalize_search_results(raw_results)

    logger.info(f"Loaded {len(products_found)} products from output.json")

    if not products_found:
        logger.warning("JSON has empty search_results.")
        # Optional: Send fallback text here if needed
        return

    # --- Step 2: Determine Template Size ---
    count = len(products_found)
    
    if count >= 10:
        selected_sid = TEMPLATE_SIDS[10]
        slice_limit = 10
    elif count >= 5:
        selected_sid = TEMPLATE_SIDS[5]
        slice_limit = 5
    elif count >= 4:
        selected_sid = TEMPLATE_SIDS[4]
        slice_limit = 4
    elif count >= 3:
        selected_sid = TEMPLATE_SIDS[3]
        slice_limit = 3
    else:
        selected_sid = TEMPLATE_SIDS[2]
        slice_limit = 2

    # --- Step 3: Slice & Pad Data ---
    products_to_send = products_found[:slice_limit]
    
    while len(products_to_send) < slice_limit:
        products_to_send.append(products_to_send[0])

    logger.info(f"Sending Template: {selected_sid} with {slice_limit} cards")

    # --- Step 4: Build Variables ---
    content_variables = {}
    current_var_index = 2
    max_var_index = (slice_limit * 4) + 1

    for p in products_to_send:
        if current_var_index > max_var_index: break
        
        p_id = p.get("prod_id") or p.get("productId") or p.get("key") or ""
        p_name = p.get("productName") or p.get("name") or "Product"
        p_cat = p.get("productCategory") or p.get("category") or "General"
        p_price = p.get("price", "0.00")
        p_url = p.get("url") or p.get("product_url") or ""

        # Image
        content_variables[str(current_var_index)] = build_cdn_url(p_id)
        current_var_index += 1
        # Title
        content_variables[str(current_var_index)] = p_name[:30] + "..." if len(p_name) > 30 else p_name
        current_var_index += 1
        # Body
        content_variables[str(current_var_index)] = f"£{p_price} | {p_cat}"
        current_var_index += 1
        # Link
        link_suffix = p_url.replace("https://www.next.co.uk/style/", "").replace("https://next.co.uk/style/", "")
        content_variables[str(current_var_index)] = link_suffix
        current_var_index += 1

    # --- Step 5: Send Carousel (FIRST) ---
    try:
        twilio_client.messages.create(
            content_sid=selected_sid,
            from_=TWILIO_WHATSAPP_FROM,
            to=user_number,
            content_variables=json.dumps(content_variables)
        )
        logger.info("Carousel sent successfully.")
    except Exception as e:
        logger.error(f"Failed to send carousel: {e}")
        return

    # --- Step 6: FORCE DELAY (CRITICAL STEP) ---
    # This 3-second pause guarantees the text arrives AFTER the carousel.
    logger.info("Waiting 3s for carousel render...")
    time.sleep(3.0)

    # --- Step 7: Send Assistant Message (SECOND) ---
    try:
        twilio_client.messages.create(
            body=assistant_message,
            from_=TWILIO_WHATSAPP_FROM,
            to=user_number
        )
        logger.info("Assistant message sent.")
    except Exception as e:
        logger.error(f"Failed to send text: {e}")

    # Log total time
    duration = time.time() - start_time
    logger.info(f"✅ Transaction Complete in {duration:.2f}s")

# -------------------------
# Webhook Endpoint
# -------------------------
@app.post("/whatsapp/webhook")
async def whatsapp_webhook(
    background_tasks: BackgroundTasks, 
    Body: str = Form(...), 
    From: str = Form(...)
):
    start_time = time.time()
    logger.info(f"Msg received from {From}")
    
    # Process everything in background
    background_tasks.add_task(process_webhook_logic, Body, From, start_time)
    
    return Response(content="<Response></Response>", media_type="application/xml")
